{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/offsets/presets.es.js"],"sourcesContent":["const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n"],"names":[],"mappings":";;;AAAA,MAAM,eAAe;IACjB,OAAO;QACH;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;IACD,MAAM;QACF;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;IACD,KAAK;QACD;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;IACD,KAAK;QACD;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;AACL"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/data.es.js"],"sourcesContent":["import { MotionValue } from '@motionone/types';\n\nconst data = new WeakMap();\nfunction getAnimationData(element) {\n    if (!data.has(element)) {\n        data.set(element, {\n            transforms: [],\n            values: new Map(),\n        });\n    }\n    return data.get(element);\n}\nfunction getMotionValue(motionValues, name) {\n    if (!motionValues.has(name)) {\n        motionValues.set(name, new MotionValue());\n    }\n    return motionValues.get(name);\n}\n\nexport { getAnimationData, getMotionValue };\n"],"names":[],"mappings":";;;;;;;AAEA,MAAM,OAAO,IAAI;AACjB,SAAS,iBAAiB,OAAO;IAC7B,IAAI,CAAC,KAAK,GAAG,CAAC,UAAU;QACpB,KAAK,GAAG,CAAC,SAAS;YACd,YAAY,EAAE;YACd,QAAQ,IAAI;QAChB;IACJ;IACA,OAAO,KAAK,GAAG,CAAC;AACpB;AACA,SAAS,eAAe,YAAY,EAAE,IAAI;IACtC,IAAI,CAAC,aAAa,GAAG,CAAC,OAAO;QACzB,aAAa,GAAG,CAAC,MAAM;IAC3B;IACA,OAAO,aAAa,GAAG,CAAC;AAC5B"}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/transforms.es.js"],"sourcesContent":["import { noopReturn, addUniqueItem } from '@motionone/utils';\nimport { getAnimationData } from '../data.es.js';\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nconst axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nconst order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\nconst transformAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\nconst rotation = {\n    syntax: \"<angle>\",\n    initialValue: \"0deg\",\n    toDefaultUnit: (v) => v + \"deg\",\n};\nconst baseTransformProperties = {\n    translate: {\n        syntax: \"<length-percentage>\",\n        initialValue: \"0px\",\n        toDefaultUnit: (v) => v + \"px\",\n    },\n    rotate: rotation,\n    scale: {\n        syntax: \"<number>\",\n        initialValue: 1,\n        toDefaultUnit: noopReturn,\n    },\n    skew: rotation,\n};\nconst transformDefinitions = new Map();\nconst asTransformCssVar = (name) => `--motion-${name}`;\n/**\n * Generate a list of every possible transform key\n */\nconst transforms = [\"x\", \"y\", \"z\"];\norder.forEach((name) => {\n    axes.forEach((axis) => {\n        transforms.push(name + axis);\n        transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nconst compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);\n/**\n * Provide a quick way to check if a string is the name of a transform\n */\nconst transformLookup = new Set(transforms);\nconst isTransform = (name) => transformLookup.has(name);\nconst addTransformToElement = (element, name) => {\n    // Map x to translateX etc\n    if (transformAlias[name])\n        name = transformAlias[name];\n    const { transforms } = getAnimationData(element);\n    addUniqueItem(transforms, name);\n    /**\n     * TODO: An optimisation here could be to cache the transform in element data\n     * and only update if this has changed.\n     */\n    element.style.transform = buildTransformTemplate(transforms);\n};\nconst buildTransformTemplate = (transforms) => transforms\n    .sort(compareTransformOrder)\n    .reduce(transformListToString, \"\")\n    .trim();\nconst transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;\n\nexport { addTransformToElement, asTransformCssVar, axes, buildTransformTemplate, compareTransformOrder, isTransform, transformAlias, transformDefinitions };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAGA;;;CAGC,GACD,MAAM,OAAO;IAAC;IAAI;IAAK;IAAK;CAAI;AAChC;;;CAGC,GACD,MAAM,QAAQ;IAAC;IAAa;IAAS;IAAU;CAAO;AACtD,MAAM,iBAAiB;IACnB,GAAG;IACH,GAAG;IACH,GAAG;AACP;AACA,MAAM,WAAW;IACb,QAAQ;IACR,cAAc;IACd,eAAe,CAAC,IAAM,IAAI;AAC9B;AACA,MAAM,0BAA0B;IAC5B,WAAW;QACP,QAAQ;QACR,cAAc;QACd,eAAe,CAAC,IAAM,IAAI;IAC9B;IACA,QAAQ;IACR,OAAO;QACH,QAAQ;QACR,cAAc;QACd,aAAa;IACjB;IACA,MAAM;AACV;AACA,MAAM,uBAAuB,IAAI;AACjC,MAAM,oBAAoB,CAAC,OAAS,CAAC,SAAS,EAAE,KAAK,CAAC;AACtD;;CAEC,GACD,MAAM,aAAa;IAAC;IAAK;IAAK;CAAI;AAClC,MAAM,OAAO,CAAC,CAAC;IACX,KAAK,OAAO,CAAC,CAAC;QACV,WAAW,IAAI,CAAC,OAAO;QACvB,qBAAqB,GAAG,CAAC,kBAAkB,OAAO,OAAO,uBAAuB,CAAC,KAAK;IAC1F;AACJ;AACA;;CAEC,GACD,MAAM,wBAAwB,CAAC,GAAG,IAAM,WAAW,OAAO,CAAC,KAAK,WAAW,OAAO,CAAC;AACnF;;CAEC,GACD,MAAM,kBAAkB,IAAI,IAAI;AAChC,MAAM,cAAc,CAAC,OAAS,gBAAgB,GAAG,CAAC;AAClD,MAAM,wBAAwB,CAAC,SAAS;IACpC,0BAA0B;IAC1B,IAAI,cAAc,CAAC,KAAK,EACpB,OAAO,cAAc,CAAC,KAAK;IAC/B,MAAM,EAAE,UAAU,EAAE,GAAG,2LAAiB;IACxC,gLAAc,YAAY;IAC1B;;;KAGC,GACD,QAAQ,KAAK,CAAC,SAAS,GAAG,uBAAuB;AACrD;AACA,MAAM,yBAAyB,CAAC,aAAe,WAC1C,IAAI,CAAC,uBACL,MAAM,CAAC,uBAAuB,IAC9B,IAAI;AACT,MAAM,wBAAwB,CAAC,UAAU,OAAS,CAAC,EAAE,SAAS,CAAC,EAAE,KAAK,KAAK,EAAE,kBAAkB,MAAM,EAAE,CAAC"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/css-var.es.js"],"sourcesContent":["import { transformDefinitions } from './transforms.es.js';\n\nconst isCssVar = (name) => name.startsWith(\"--\");\nconst registeredProperties = new Set();\nfunction registerCssVariable(name) {\n    if (registeredProperties.has(name))\n        return;\n    registeredProperties.add(name);\n    try {\n        const { syntax, initialValue } = transformDefinitions.has(name)\n            ? transformDefinitions.get(name)\n            : {};\n        CSS.registerProperty({\n            name,\n            inherits: false,\n            syntax,\n            initialValue,\n        });\n    }\n    catch (e) { }\n}\n\nexport { isCssVar, registerCssVariable, registeredProperties };\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAM,WAAW,CAAC,OAAS,KAAK,UAAU,CAAC;AAC3C,MAAM,uBAAuB,IAAI;AACjC,SAAS,oBAAoB,IAAI;IAC7B,IAAI,qBAAqB,GAAG,CAAC,OACzB;IACJ,qBAAqB,GAAG,CAAC;IACzB,IAAI;QACA,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG,8MAAqB,GAAG,CAAC,QACpD,8MAAqB,GAAG,CAAC,QACzB,CAAC;QACP,IAAI,gBAAgB,CAAC;YACjB;YACA,UAAU;YACV;YACA;QACJ;IACJ,EACA,OAAO,GAAG,CAAE;AAChB"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/easing.es.js"],"sourcesContent":["import { isCubicBezier } from '@motionone/utils';\n\nconst convertEasing = (easing) => isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { convertEasing, cubicBezierAsString };\n"],"names":[],"mappings":";;;;;;;AAEA,MAAM,gBAAgB,CAAC,SAAW,gMAAc,UAAU,oBAAoB,UAAU;AACxF,MAAM,sBAAsB,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,GAAK,CAAC,aAAa,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC"}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js"],"sourcesContent":["const testAnimation = (keyframes) => document.createElement(\"div\").animate(keyframes, { duration: 0.001 });\nconst featureTests = {\n    cssRegisterProperty: () => typeof CSS !== \"undefined\" &&\n        Object.hasOwnProperty.call(CSS, \"registerProperty\"),\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\n    partialKeyframes: () => {\n        try {\n            testAnimation({ opacity: [1] });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n    finished: () => Boolean(testAnimation({ opacity: [0, 1] }).finished),\n};\nconst results = {};\nconst supports = {};\nfor (const key in featureTests) {\n    supports[key] = () => {\n        if (results[key] === undefined)\n            results[key] = featureTests[key]();\n        return results[key];\n    };\n}\n\nexport { supports };\n"],"names":[],"mappings":";;;AAAA,MAAM,gBAAgB,CAAC,YAAc,SAAS,aAAa,CAAC,OAAO,OAAO,CAAC,WAAW;QAAE,UAAU;IAAM;AACxG,MAAM,eAAe;IACjB,qBAAqB,IAAM,OAAO,QAAQ,eACtC,OAAO,cAAc,CAAC,IAAI,CAAC,KAAK;IACpC,OAAO,IAAM,OAAO,cAAc,CAAC,IAAI,CAAC,QAAQ,SAAS,EAAE;IAC3D,kBAAkB;QACd,IAAI;YACA,cAAc;gBAAE,SAAS;oBAAC;iBAAE;YAAC;QACjC,EACA,OAAO,GAAG;YACN,OAAO;QACX;QACA,OAAO;IACX;IACA,UAAU,IAAM,QAAQ,cAAc;YAAE,SAAS;gBAAC;gBAAG;aAAE;QAAC,GAAG,QAAQ;AACvE;AACA,MAAM,UAAU,CAAC;AACjB,MAAM,WAAW,CAAC;AAClB,IAAK,MAAM,OAAO,aAAc;IAC5B,QAAQ,CAAC,IAAI,GAAG;QACZ,IAAI,OAAO,CAAC,IAAI,KAAK,WACjB,OAAO,CAAC,IAAI,GAAG,YAAY,CAAC,IAAI;QACpC,OAAO,OAAO,CAAC,IAAI;IACvB;AACJ"}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js"],"sourcesContent":["function hydrateKeyframes(keyframes, readInitialValue) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] === null) {\n            keyframes[i] = i ? keyframes[i - 1] : readInitialValue();\n        }\n    }\n    return keyframes;\n}\nconst keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];\n\nexport { hydrateKeyframes, keyframesList };\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAiB,SAAS,EAAE,gBAAgB;IACjD,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QACvC,IAAI,SAAS,CAAC,EAAE,KAAK,MAAM;YACvB,SAAS,CAAC,EAAE,GAAG,IAAI,SAAS,CAAC,IAAI,EAAE,GAAG;QAC1C;IACJ;IACA,OAAO;AACX;AACA,MAAM,gBAAgB,CAAC,YAAc,MAAM,OAAO,CAAC,aAAa,YAAY;QAAC;KAAU"}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js"],"sourcesContent":["import { isTransform, asTransformCssVar, transformAlias } from './transforms.es.js';\n\nfunction getStyleName(key) {\n    if (transformAlias[key])\n        key = transformAlias[key];\n    return isTransform(key) ? asTransformCssVar(key) : key;\n}\n\nexport { getStyleName };\n"],"names":[],"mappings":";;;;;;AAEA,SAAS,aAAa,GAAG;IACrB,IAAI,uMAAc,CAAC,IAAI,EACnB,MAAM,uMAAc,CAAC,IAAI;IAC7B,OAAO,qMAAY,OAAO,2MAAkB,OAAO;AACvD"}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/style.es.js"],"sourcesContent":["import { isCssVar } from './utils/css-var.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { transformDefinitions } from './utils/transforms.es.js';\n\nconst style = {\n    get: (element, name) => {\n        name = getStyleName(name);\n        let value = isCssVar(name)\n            ? element.style.getPropertyValue(name)\n            : getComputedStyle(element)[name];\n        if (!value && value !== 0) {\n            const definition = transformDefinitions.get(name);\n            if (definition)\n                value = definition.initialValue;\n        }\n        return value;\n    },\n    set: (element, name, value) => {\n        name = getStyleName(name);\n        if (isCssVar(name)) {\n            element.style.setProperty(name, value);\n        }\n        else {\n            element.style[name] = value;\n        }\n    },\n};\n\nexport { style };\n"],"names":[],"mappings":";;;;;;;;;;AAIA,MAAM,QAAQ;IACV,KAAK,CAAC,SAAS;QACX,OAAO,gNAAa;QACpB,IAAI,QAAQ,kMAAS,QACf,QAAQ,KAAK,CAAC,gBAAgB,CAAC,QAC/B,iBAAiB,QAAQ,CAAC,KAAK;QACrC,IAAI,CAAC,SAAS,UAAU,GAAG;YACvB,MAAM,aAAa,8MAAqB,GAAG,CAAC;YAC5C,IAAI,YACA,QAAQ,WAAW,YAAY;QACvC;QACA,OAAO;IACX;IACA,KAAK,CAAC,SAAS,MAAM;QACjB,OAAO,gNAAa;QACpB,IAAI,kMAAS,OAAO;YAChB,QAAQ,KAAK,CAAC,WAAW,CAAC,MAAM;QACpC,OACK;YACD,QAAQ,KAAK,CAAC,KAAK,GAAG;QAC1B;IACJ;AACJ"}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 372, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js"],"sourcesContent":["function stopAnimation(animation, needsCommit = true) {\n    if (!animation || animation.playState === \"finished\")\n        return;\n    // Suppress error thrown by WAAPI\n    try {\n        if (animation.stop) {\n            animation.stop();\n        }\n        else {\n            needsCommit && animation.commitStyles();\n            animation.cancel();\n        }\n    }\n    catch (e) { }\n}\n\nexport { stopAnimation };\n"],"names":[],"mappings":";;;AAAA,SAAS,cAAc,SAAS,EAAE,cAAc,IAAI;IAChD,IAAI,CAAC,aAAa,UAAU,SAAS,KAAK,YACtC;IACJ,iCAAiC;IACjC,IAAI;QACA,IAAI,UAAU,IAAI,EAAE;YAChB,UAAU,IAAI;QAClB,OACK;YACD,eAAe,UAAU,YAAY;YACrC,UAAU,MAAM;QACpB;IACJ,EACA,OAAO,GAAG,CAAE;AAChB"}},
    {"offset": {"line": 388, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/animate-style.es.js"],"sourcesContent":["import { getAnimationData, getMotionValue } from './data.es.js';\nimport { isCssVar, registerCssVariable } from './utils/css-var.es.js';\nimport { Animation } from '@motionone/animation';\nimport { defaults, isEasingGenerator, isNumber, time, isEasingList, noop } from '@motionone/utils';\nimport { isTransform, addTransformToElement, transformDefinitions } from './utils/transforms.es.js';\nimport { convertEasing } from './utils/easing.es.js';\nimport { supports } from './utils/feature-detection.es.js';\nimport { hydrateKeyframes, keyframesList } from './utils/keyframes.es.js';\nimport { style } from './style.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { stopAnimation } from './utils/stop-animation.es.js';\n\nfunction getDevToolsRecord() {\n    return window.__MOTION_DEV_TOOLS_RECORD;\n}\nfunction animateStyle(element, key, keyframesDefinition, options = {}) {\n    const record = getDevToolsRecord();\n    const isRecording = options.record !== false && record;\n    let animation;\n    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, direction, offset, allowWebkitAcceleration = false, } = options;\n    const data = getAnimationData(element);\n    let canAnimateNatively = supports.waapi();\n    const valueIsTransform = isTransform(key);\n    /**\n     * If this is an individual transform, we need to map its\n     * key to a CSS variable and update the element's transform style\n     */\n    valueIsTransform && addTransformToElement(element, key);\n    const name = getStyleName(key);\n    const motionValue = getMotionValue(data.values, name);\n    /**\n     * Get definition of value, this will be used to convert numerical\n     * keyframes into the default value type.\n     */\n    const definition = transformDefinitions.get(name);\n    /**\n     * Stop the current animation, if any. Because this will trigger\n     * commitStyles (DOM writes) and we might later trigger DOM reads,\n     * this is fired now and we return a factory function to create\n     * the actual animation that can get called in batch,\n     */\n    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&\n        options.record !== false);\n    /**\n     * Batchable factory function containing all DOM reads.\n     */\n    return () => {\n        const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };\n        /**\n         * Replace null values with the previous keyframe value, or read\n         * it from the DOM if it's the first keyframe.\n         */\n        let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, readInitialValue, valueIsTransform, name, motionValue);\n            easing = custom.easing;\n            if (custom.keyframes !== undefined)\n                keyframes = custom.keyframes;\n            if (custom.duration !== undefined)\n                duration = custom.duration;\n        }\n        /**\n         * If this is a CSS variable we need to register it with the browser\n         * before it can be animated natively. We also set it with setProperty\n         * rather than directly onto the element.style object.\n         */\n        if (isCssVar(name)) {\n            if (supports.cssRegisterProperty()) {\n                registerCssVariable(name);\n            }\n            else {\n                canAnimateNatively = false;\n            }\n        }\n        /**\n         * If we can animate this value with WAAPI, do so. Currently this only\n         * feature detects CSS.registerProperty but could check WAAPI too.\n         */\n        if (canAnimateNatively) {\n            /**\n             * Convert numbers to default value types. Currently this only supports\n             * transforms but it could also support other value types.\n             */\n            if (definition) {\n                keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);\n            }\n            /**\n             * If this browser doesn't support partial/implicit keyframes we need to\n             * explicitly provide one.\n             */\n            if (keyframes.length === 1 &&\n                (!supports.partialKeyframes() || isRecording)) {\n                keyframes.unshift(readInitialValue());\n            }\n            const animationOptions = {\n                delay: time.ms(delay),\n                duration: time.ms(duration),\n                endDelay: time.ms(endDelay),\n                easing: !isEasingList(easing) ? convertEasing(easing) : undefined,\n                direction,\n                iterations: repeat + 1,\n                fill: \"both\",\n            };\n            animation = element.animate({\n                [name]: keyframes,\n                offset,\n                easing: isEasingList(easing) ? easing.map(convertEasing) : undefined,\n            }, animationOptions);\n            /**\n             * Polyfill finished Promise in browsers that don't support it\n             */\n            if (!animation.finished) {\n                animation.finished = new Promise((resolve, reject) => {\n                    animation.onfinish = resolve;\n                    animation.oncancel = reject;\n                });\n            }\n            const target = keyframes[keyframes.length - 1];\n            animation.finished\n                .then(() => {\n                // Apply styles to target\n                style.set(element, name, target);\n                // Ensure fill modes don't persist\n                animation.cancel();\n            })\n                .catch(noop);\n            /**\n             * This forces Webkit to run animations on the main thread by exploiting\n             * this condition:\n             * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099\n             *\n             * This fixes Webkit's timing bugs, like accelerated animations falling\n             * out of sync with main thread animations and massive delays in starting\n             * accelerated animations in WKWebView.\n             */\n            if (!allowWebkitAcceleration)\n                animation.playbackRate = 1.000001;\n            /**\n             * If we can't animate the value natively then we can fallback to the numbers-only\n             * polyfill for transforms.\n             */\n        }\n        else if (valueIsTransform) {\n            /**\n             * If any keyframe is a string (because we measured it from the DOM), we need to convert\n             * it into a number before passing to the Animation polyfill.\n             */\n            keyframes = keyframes.map((value) => typeof value === \"string\" ? parseFloat(value) : value);\n            /**\n             * If we only have a single keyframe, we need to create an initial keyframe by reading\n             * the current value from the DOM.\n             */\n            if (keyframes.length === 1) {\n                keyframes.unshift(parseFloat(readInitialValue()));\n            }\n            const render = (latest) => {\n                if (definition)\n                    latest = definition.toDefaultUnit(latest);\n                style.set(element, name, latest);\n            };\n            animation = new Animation(render, keyframes, Object.assign(Object.assign({}, options), { duration,\n                easing }));\n        }\n        else {\n            const target = keyframes[keyframes.length - 1];\n            style.set(element, name, definition && isNumber(target)\n                ? definition.toDefaultUnit(target)\n                : target);\n        }\n        if (isRecording) {\n            record(element, key, keyframes, {\n                duration,\n                delay: delay,\n                easing,\n                repeat,\n                offset,\n            }, \"motion-one\");\n        }\n        motionValue.setAnimation(animation);\n        return animation;\n    };\n}\n\nexport { animateStyle };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 573, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/options.es.js"],"sourcesContent":["const getOptions = (options, key) => \n/**\n * TODO: Make test for this\n * Always return a new object otherwise delay is overwritten by results of stagger\n * and this results in no stagger\n */\noptions[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);\n\nexport { getOptions };\n"],"names":[],"mappings":";;;AAAA,MAAM,aAAa,CAAC,SAAS,MAC7B;;;;CAIC,GACD,OAAO,CAAC,IAAI,GAAG,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,CAAC,GAAG,UAAU,OAAO,CAAC,IAAI,IAAI,OAAO,MAAM,CAAC,CAAC,GAAG"}},
    {"offset": {"line": 587, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 592, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/utils/resolve-elements.es.js"],"sourcesContent":["function resolveElements(elements, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = document.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nexport { resolveElements };\n"],"names":[],"mappings":";;;AAAA,SAAS,gBAAgB,QAAQ,EAAE,aAAa;IAC5C,IAAI;IACJ,IAAI,OAAO,aAAa,UAAU;QAC9B,IAAI,eAAe;YACf,CAAC,KAAK,aAAa,CAAC,SAAS,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAM,aAAa,CAAC,SAAS,GAAG,SAAS,gBAAgB,CAAC;YACrH,WAAW,aAAa,CAAC,SAAS;QACtC,OACK;YACD,WAAW,SAAS,gBAAgB,CAAC;QACzC;IACJ,OACK,IAAI,oBAAoB,SAAS;QAClC,WAAW;YAAC;SAAS;IACzB;IACA;;KAEC,GACD,OAAO,MAAM,IAAI,CAAC,YAAY,EAAE;AACpC"}},
    {"offset": {"line": 614, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 619, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/controls.es.js"],"sourcesContent":["import { defaults, noop, time } from '@motionone/utils';\nimport { stopAnimation } from './stop-animation.es.js';\n\nconst createAnimation = (factory) => factory();\nconst withControls = (animationFactory, options, duration = defaults.duration) => {\n    return new Proxy({\n        animations: animationFactory.map(createAnimation).filter(Boolean),\n        duration,\n        options,\n    }, controls);\n};\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\nconst getActiveAnimation = (state) => state.animations[0];\nconst controls = {\n    get: (target, key) => {\n        const activeAnimation = getActiveAnimation(target);\n        switch (key) {\n            case \"duration\":\n                return target.duration;\n            case \"currentTime\":\n                return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);\n            case \"playbackRate\":\n            case \"playState\":\n                return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];\n            case \"finished\":\n                if (!target.finished) {\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);\n                }\n                return target.finished;\n            case \"stop\":\n                return () => {\n                    target.animations.forEach((animation) => stopAnimation(animation));\n                };\n            case \"forEachNative\":\n                /**\n                 * This is for internal use only, fire a callback for each\n                 * underlying animation.\n                 */\n                return (callback) => {\n                    target.animations.forEach((animation) => callback(animation, target));\n                };\n            default:\n                return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === \"undefined\"\n                    ? undefined\n                    : () => target.animations.forEach((animation) => animation[key]());\n        }\n    },\n    set: (target, key, value) => {\n        switch (key) {\n            case \"currentTime\":\n                value = time.ms(value);\n            case \"currentTime\":\n            case \"playbackRate\":\n                for (let i = 0; i < target.animations.length; i++) {\n                    target.animations[i][key] = value;\n                }\n                return true;\n        }\n        return false;\n    },\n};\nconst selectFinished = (animation) => animation.finished;\n\nexport { controls, withControls };\n"],"names":[],"mappings":";;;;;;;;;;;AAGA,MAAM,kBAAkB,CAAC,UAAY;AACrC,MAAM,eAAe,CAAC,kBAAkB,SAAS,WAAW,8KAAS,QAAQ;IACzE,OAAO,IAAI,MAAM;QACb,YAAY,iBAAiB,GAAG,CAAC,iBAAiB,MAAM,CAAC;QACzD;QACA;IACJ,GAAG;AACP;AACA;;;;CAIC,GACD,MAAM,qBAAqB,CAAC,QAAU,MAAM,UAAU,CAAC,EAAE;AACzD,MAAM,WAAW;IACb,KAAK,CAAC,QAAQ;QACV,MAAM,kBAAkB,mBAAmB;QAC3C,OAAQ;YACJ,KAAK;gBACD,OAAO,OAAO,QAAQ;YAC1B,KAAK;gBACD,OAAO,sKAAK,CAAC,CAAC,CAAC,oBAAoB,QAAQ,oBAAoB,KAAK,IAAI,KAAK,IAAI,eAAe,CAAC,IAAI,KAAK;YAC9G,KAAK;YACL,KAAK;gBACD,OAAO,oBAAoB,QAAQ,oBAAoB,KAAK,IAAI,KAAK,IAAI,eAAe,CAAC,IAAI;YACjG,KAAK;gBACD,IAAI,CAAC,OAAO,QAAQ,EAAE;oBAClB,OAAO,QAAQ,GAAG,QAAQ,GAAG,CAAC,OAAO,UAAU,CAAC,GAAG,CAAC,iBAAiB,KAAK;gBAC9E;gBACA,OAAO,OAAO,QAAQ;YAC1B,KAAK;gBACD,OAAO;oBACH,OAAO,UAAU,CAAC,OAAO,CAAC,CAAC,YAAc,8MAAc;gBAC3D;YACJ,KAAK;gBACD;;;iBAGC,GACD,OAAO,CAAC;oBACJ,OAAO,UAAU,CAAC,OAAO,CAAC,CAAC,YAAc,SAAS,WAAW;gBACjE;YACJ;gBACI,OAAO,OAAO,CAAC,oBAAoB,QAAQ,oBAAoB,KAAK,IAAI,KAAK,IAAI,eAAe,CAAC,IAAI,MAAM,cACrG,YACA,IAAM,OAAO,UAAU,CAAC,OAAO,CAAC,CAAC,YAAc,SAAS,CAAC,IAAI;QAC3E;IACJ;IACA,KAAK,CAAC,QAAQ,KAAK;QACf,OAAQ;YACJ,KAAK;gBACD,QAAQ,sKAAK,EAAE,CAAC;YACpB,KAAK;YACL,KAAK;gBACD,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE,IAAK;oBAC/C,OAAO,UAAU,CAAC,EAAE,CAAC,IAAI,GAAG;gBAChC;gBACA,OAAO;QACf;QACA,OAAO;IACX;AACJ;AACA,MAAM,iBAAiB,CAAC,YAAc,UAAU,QAAQ"}},
    {"offset": {"line": 690, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 695, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/utils/stagger.es.js"],"sourcesContent":["import { isNumber } from '@motionone/utils';\nimport { getEasingFunction } from '@motionone/animation';\n\nfunction stagger(duration = 0.1, { start = 0, from = 0, easing } = {}) {\n    return (i, total) => {\n        const fromIndex = isNumber(from) ? from : getFromIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (easing) {\n            const maxDelay = total * duration;\n            const easingFunction = getEasingFunction(easing);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return start + delay;\n    };\n}\nfunction getFromIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction resolveOption(option, i, total) {\n    return typeof option === \"function\"\n        ? option(i, total)\n        : option;\n}\n\nexport { getFromIndex, resolveOption, stagger };\n"],"names":[],"mappings":";;;;;;;;;;AAGA,SAAS,QAAQ,WAAW,GAAG,EAAE,EAAE,QAAQ,CAAC,EAAE,OAAO,CAAC,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IACjE,OAAO,CAAC,GAAG;QACP,MAAM,YAAY,kLAAS,QAAQ,OAAO,aAAa,MAAM;QAC7D,MAAM,WAAW,KAAK,GAAG,CAAC,YAAY;QACtC,IAAI,QAAQ,WAAW;QACvB,IAAI,QAAQ;YACR,MAAM,WAAW,QAAQ;YACzB,MAAM,iBAAiB,kMAAkB;YACzC,QAAQ,eAAe,QAAQ,YAAY;QAC/C;QACA,OAAO,QAAQ;IACnB;AACJ;AACA,SAAS,aAAa,IAAI,EAAE,KAAK;IAC7B,IAAI,SAAS,SAAS;QAClB,OAAO;IACX,OACK;QACD,MAAM,YAAY,QAAQ;QAC1B,OAAO,SAAS,SAAS,YAAY,YAAY;IACrD;AACJ;AACA,SAAS,cAAc,MAAM,EAAE,CAAC,EAAE,KAAK;IACnC,OAAO,OAAO,WAAW,aACnB,OAAO,GAAG,SACV;AACV"}},
    {"offset": {"line": 730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 735, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/index.es.js"],"sourcesContent":["import { animateStyle } from './animate-style.es.js';\nimport { getOptions } from './utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { withControls } from './utils/controls.es.js';\nimport { resolveOption } from '../utils/stagger.es.js';\n\nfunction animate(elements, keyframes, options = {}) {\n    elements = resolveElements(elements);\n    const numElements = elements.length;\n    /**\n     * Create and start new animations\n     */\n    const animationFactories = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        for (const key in keyframes) {\n            const valueOptions = getOptions(options, key);\n            valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);\n            const animation = animateStyle(element, key, keyframes[key], valueOptions);\n            animationFactories.push(animation);\n        }\n    }\n    return withControls(animationFactories, options, \n    /**\n     * TODO:\n     * If easing is set to spring or glide, duration will be dynamically\n     * generated. Ideally we would dynamically generate this from\n     * animation.effect.getComputedTiming().duration but this isn't\n     * supported in iOS13 or our number polyfill. Perhaps it's possible\n     * to Proxy animations returned from animateStyle that has duration\n     * as a getter.\n     */\n    options.duration);\n}\n\nexport { animate };\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAMA,SAAS,QAAQ,QAAQ,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;IAC9C,WAAW,uMAAgB;IAC3B,MAAM,cAAc,SAAS,MAAM;IACnC;;KAEC,GACD,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,IAAK;QAClC,MAAM,UAAU,QAAQ,CAAC,EAAE;QAC3B,IAAK,MAAM,OAAO,UAAW;YACzB,MAAM,eAAe,iMAAW,SAAS;YACzC,aAAa,KAAK,GAAG,yLAAc,aAAa,KAAK,EAAE,GAAG;YAC1D,MAAM,YAAY,mMAAa,SAAS,KAAK,SAAS,CAAC,IAAI,EAAE;YAC7D,mBAAmB,IAAI,CAAC;QAC5B;IACJ;IACA,OAAO,oMAAa,oBAAoB,SACxC;;;;;;;;KAQC,GACD,QAAQ,QAAQ;AACpB"}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 780, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/utils/has-changed.es.js"],"sourcesContent":["function hasChanged(a, b) {\n    if (typeof a !== typeof b)\n        return true;\n    if (Array.isArray(a) && Array.isArray(b))\n        return !shallowCompare(a, b);\n    return a !== b;\n}\nfunction shallowCompare(next, prev) {\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\nexport { hasChanged, shallowCompare };\n"],"names":[],"mappings":";;;;AAAA,SAAS,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,OAAO,MAAM,OAAO,GACpB,OAAO;IACX,IAAI,MAAM,OAAO,CAAC,MAAM,MAAM,OAAO,CAAC,IAClC,OAAO,CAAC,eAAe,GAAG;IAC9B,OAAO,MAAM;AACjB;AACA,SAAS,eAAe,IAAI,EAAE,IAAI;IAC9B,MAAM,aAAa,KAAK,MAAM;IAC9B,IAAI,eAAe,KAAK,MAAM,EAC1B,OAAO;IACX,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,IAAK;QACjC,IAAI,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,EACnB,OAAO;IACf;IACA,OAAO;AACX"}},
    {"offset": {"line": 798, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 803, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/utils/is-variant.es.js"],"sourcesContent":["function isVariant(definition) {\n    return typeof definition === \"object\";\n}\n\nexport { isVariant };\n"],"names":[],"mappings":";;;AAAA,SAAS,UAAU,UAAU;IACzB,OAAO,OAAO,eAAe;AACjC"}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 815, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/utils/resolve-variant.es.js"],"sourcesContent":["import { isVariant } from './is-variant.es.js';\n\nfunction resolveVariant(definition, variants) {\n    if (isVariant(definition)) {\n        return definition;\n    }\n    else if (definition && variants) {\n        return variants[definition];\n    }\n}\n\nexport { resolveVariant };\n"],"names":[],"mappings":";;;;;;AAEA,SAAS,eAAe,UAAU,EAAE,QAAQ;IACxC,IAAI,oMAAU,aAAa;QACvB,OAAO;IACX,OACK,IAAI,cAAc,UAAU;QAC7B,OAAO,QAAQ,CAAC,WAAW;IAC/B;AACJ"}},
    {"offset": {"line": 829, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 834, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/utils/schedule.es.js"],"sourcesContent":["import { addUniqueItem, removeItem } from '@motionone/utils';\n\nlet scheduled = undefined;\nfunction processScheduledAnimations() {\n    if (!scheduled)\n        return;\n    const generators = scheduled.sort(compareByDepth).map(fireAnimateUpdates);\n    generators.forEach(fireNext);\n    generators.forEach(fireNext);\n    scheduled = undefined;\n}\nfunction scheduleAnimation(state) {\n    if (!scheduled) {\n        scheduled = [state];\n        requestAnimationFrame(processScheduledAnimations);\n    }\n    else {\n        addUniqueItem(scheduled, state);\n    }\n}\nfunction unscheduleAnimation(state) {\n    scheduled && removeItem(scheduled, state);\n}\nconst compareByDepth = (a, b) => a.getDepth() - b.getDepth();\nconst fireAnimateUpdates = (state) => state.animateUpdates();\nconst fireNext = (iterator) => iterator.next();\n\nexport { scheduleAnimation, unscheduleAnimation };\n"],"names":[],"mappings":";;;;;;;AAEA,IAAI,YAAY;AAChB,SAAS;IACL,IAAI,CAAC,WACD;IACJ,MAAM,aAAa,UAAU,IAAI,CAAC,gBAAgB,GAAG,CAAC;IACtD,WAAW,OAAO,CAAC;IACnB,WAAW,OAAO,CAAC;IACnB,YAAY;AAChB;AACA,SAAS,kBAAkB,KAAK;IAC5B,IAAI,CAAC,WAAW;QACZ,YAAY;YAAC;SAAM;QACnB,sBAAsB;IAC1B,OACK;QACD,gLAAc,WAAW;IAC7B;AACJ;AACA,SAAS,oBAAoB,KAAK;IAC9B,aAAa,6KAAW,WAAW;AACvC;AACA,MAAM,iBAAiB,CAAC,GAAG,IAAM,EAAE,QAAQ,KAAK,EAAE,QAAQ;AAC1D,MAAM,qBAAqB,CAAC,QAAU,MAAM,cAAc;AAC1D,MAAM,WAAW,CAAC,WAAa,SAAS,IAAI"}},
    {"offset": {"line": 866, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 871, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/utils/events.es.js"],"sourcesContent":["const motionEvent = (name, target) => new CustomEvent(name, { detail: { target } });\nfunction dispatchPointerEvent(element, name, event) {\n    element.dispatchEvent(new CustomEvent(name, { detail: { originalEvent: event } }));\n}\nfunction dispatchViewEvent(element, name, entry) {\n    element.dispatchEvent(new CustomEvent(name, { detail: { originalEntry: entry } }));\n}\n\nexport { dispatchPointerEvent, dispatchViewEvent, motionEvent };\n"],"names":[],"mappings":";;;;;AAAA,MAAM,cAAc,CAAC,MAAM,SAAW,IAAI,YAAY,MAAM;QAAE,QAAQ;YAAE;QAAO;IAAE;AACjF,SAAS,qBAAqB,OAAO,EAAE,IAAI,EAAE,KAAK;IAC9C,QAAQ,aAAa,CAAC,IAAI,YAAY,MAAM;QAAE,QAAQ;YAAE,eAAe;QAAM;IAAE;AACnF;AACA,SAAS,kBAAkB,OAAO,EAAE,IAAI,EAAE,KAAK;IAC3C,QAAQ,aAAa,CAAC,IAAI,YAAY,MAAM;QAAE,QAAQ;YAAE,eAAe;QAAM;IAAE;AACnF"}},
    {"offset": {"line": 896, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 901, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/in-view.es.js"],"sourcesContent":["import { resolveElements } from '../utils/resolve-elements.es.js';\n\nconst thresholds = {\n    any: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"any\" } = {}) {\n    /**\n     * If this browser doesn't support IntersectionObserver, return a dummy stop function.\n     * Default triggering of onStart is tricky - it could be used for starting/stopping\n     * videos, lazy loading content etc. We could provide an option to enable a fallback, or\n     * provide a fallback callback option.\n     */\n    if (typeof IntersectionObserver === \"undefined\") {\n        return () => { };\n    }\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (onEnd) {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\nexport { inView };\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,aAAa;IACf,KAAK;IACL,KAAK;AACT;AACA,SAAS,OAAO,iBAAiB,EAAE,OAAO,EAAE,EAAE,IAAI,EAAE,QAAQ,UAAU,EAAE,SAAS,KAAK,EAAE,GAAG,CAAC,CAAC;IACzF;;;;;KAKC,GACD,IAAI,OAAO,yBAAyB,aAAa;QAC7C,OAAO,KAAQ;IACnB;IACA,MAAM,WAAW,uMAAgB;IACjC,MAAM,sBAAsB,IAAI;IAChC,MAAM,uBAAuB,CAAC;QAC1B,QAAQ,OAAO,CAAC,CAAC;YACb,MAAM,QAAQ,oBAAoB,GAAG,CAAC,MAAM,MAAM;YAClD;;;aAGC,GACD,IAAI,MAAM,cAAc,KAAK,QAAQ,QACjC;YACJ,IAAI,MAAM,cAAc,EAAE;gBACtB,MAAM,WAAW,QAAQ;gBACzB,IAAI,OAAO,aAAa,YAAY;oBAChC,oBAAoB,GAAG,CAAC,MAAM,MAAM,EAAE;gBAC1C,OACK;oBACD,SAAS,SAAS,CAAC,MAAM,MAAM;gBACnC;YACJ,OACK,IAAI,OAAO;gBACZ,MAAM;gBACN,oBAAoB,MAAM,CAAC,MAAM,MAAM;YAC3C;QACJ;IACJ;IACA,MAAM,WAAW,IAAI,qBAAqB,sBAAsB;QAC5D;QACA;QACA,WAAW,OAAO,WAAW,WAAW,SAAS,UAAU,CAAC,OAAO;IACvE;IACA,SAAS,OAAO,CAAC,CAAC,UAAY,SAAS,OAAO,CAAC;IAC/C,OAAO,IAAM,SAAS,UAAU;AACpC"}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 956, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/gestures/in-view.es.js"],"sourcesContent":["import { __rest } from 'tslib';\nimport { dispatchViewEvent } from '../utils/events.es.js';\nimport { inView as inView$1 } from '../../gestures/in-view.es.js';\n\nconst inView = {\n    isActive: (options) => Boolean(options.inView),\n    subscribe: (element, { enable, disable }, { inViewOptions = {} }) => {\n        const { once } = inViewOptions, viewOptions = __rest(inViewOptions, [\"once\"]);\n        return inView$1(element, (enterEntry) => {\n            enable();\n            dispatchViewEvent(element, \"viewenter\", enterEntry);\n            if (!once) {\n                return (leaveEntry) => {\n                    disable();\n                    dispatchViewEvent(element, \"viewleave\", leaveEntry);\n                };\n            }\n        }, viewOptions);\n    },\n};\n\nexport { inView };\n"],"names":[],"mappings":";;;;;;;;;;AAIA,MAAM,SAAS;IACX,UAAU,CAAC,UAAY,QAAQ,QAAQ,MAAM;IAC7C,WAAW,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE,gBAAgB,CAAC,CAAC,EAAE;QAC5D,MAAM,EAAE,IAAI,EAAE,GAAG,eAAe,cAAc,oJAAO,eAAe;YAAC;SAAO;QAC5E,OAAO,wLAAS,SAAS,CAAC;YACtB;YACA,qMAAkB,SAAS,aAAa;YACxC,IAAI,CAAC,MAAM;gBACP,OAAO,CAAC;oBACJ;oBACA,qMAAkB,SAAS,aAAa;gBAC5C;YACJ;QACJ,GAAG;IACP;AACJ"}},
    {"offset": {"line": 985, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 990, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/gestures/hover.es.js"],"sourcesContent":["import { dispatchPointerEvent } from '../utils/events.es.js';\n\nconst mouseEvent = (element, name, action) => (event) => {\n    if (event.pointerType && event.pointerType !== \"mouse\")\n        return;\n    action();\n    dispatchPointerEvent(element, name, event);\n};\nconst hover = {\n    isActive: (options) => Boolean(options.hover),\n    subscribe: (element, { enable, disable }) => {\n        const onEnter = mouseEvent(element, \"hoverstart\", enable);\n        const onLeave = mouseEvent(element, \"hoverend\", disable);\n        element.addEventListener(\"pointerenter\", onEnter);\n        element.addEventListener(\"pointerleave\", onLeave);\n        return () => {\n            element.removeEventListener(\"pointerenter\", onEnter);\n            element.removeEventListener(\"pointerleave\", onLeave);\n        };\n    },\n};\n\nexport { hover };\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,aAAa,CAAC,SAAS,MAAM,SAAW,CAAC;QAC3C,IAAI,MAAM,WAAW,IAAI,MAAM,WAAW,KAAK,SAC3C;QACJ;QACA,wMAAqB,SAAS,MAAM;IACxC;AACA,MAAM,QAAQ;IACV,UAAU,CAAC,UAAY,QAAQ,QAAQ,KAAK;IAC5C,WAAW,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE;QACpC,MAAM,UAAU,WAAW,SAAS,cAAc;QAClD,MAAM,UAAU,WAAW,SAAS,YAAY;QAChD,QAAQ,gBAAgB,CAAC,gBAAgB;QACzC,QAAQ,gBAAgB,CAAC,gBAAgB;QACzC,OAAO;YACH,QAAQ,mBAAmB,CAAC,gBAAgB;YAC5C,QAAQ,mBAAmB,CAAC,gBAAgB;QAChD;IACJ;AACJ"}},
    {"offset": {"line": 1015, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1020, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/gestures/press.es.js"],"sourcesContent":["import { dispatchPointerEvent } from '../utils/events.es.js';\n\nconst press = {\n    isActive: (options) => Boolean(options.press),\n    subscribe: (element, { enable, disable }) => {\n        const onPointerUp = (event) => {\n            disable();\n            dispatchPointerEvent(element, \"pressend\", event);\n            window.removeEventListener(\"pointerup\", onPointerUp);\n        };\n        const onPointerDown = (event) => {\n            enable();\n            dispatchPointerEvent(element, \"pressstart\", event);\n            window.addEventListener(\"pointerup\", onPointerUp);\n        };\n        element.addEventListener(\"pointerdown\", onPointerDown);\n        return () => {\n            element.removeEventListener(\"pointerdown\", onPointerDown);\n            window.removeEventListener(\"pointerup\", onPointerUp);\n        };\n    },\n};\n\nexport { press };\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,QAAQ;IACV,UAAU,CAAC,UAAY,QAAQ,QAAQ,KAAK;IAC5C,WAAW,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE;QACpC,MAAM,cAAc,CAAC;YACjB;YACA,wMAAqB,SAAS,YAAY;YAC1C,OAAO,mBAAmB,CAAC,aAAa;QAC5C;QACA,MAAM,gBAAgB,CAAC;YACnB;YACA,wMAAqB,SAAS,cAAc;YAC5C,OAAO,gBAAgB,CAAC,aAAa;QACzC;QACA,QAAQ,gBAAgB,CAAC,eAAe;QACxC,OAAO;YACH,QAAQ,mBAAmB,CAAC,eAAe;YAC3C,OAAO,mBAAmB,CAAC,aAAa;QAC5C;IACJ;AACJ"}},
    {"offset": {"line": 1047, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1052, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/state/index.es.js"],"sourcesContent":["import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { noop } from '@motionone/utils';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { style } from '../animate/style.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { hasChanged } from './utils/has-changed.es.js';\nimport { resolveVariant } from './utils/resolve-variant.es.js';\nimport { scheduleAnimation, unscheduleAnimation } from './utils/schedule.es.js';\nimport { inView } from './gestures/in-view.es.js';\nimport { hover } from './gestures/hover.es.js';\nimport { press } from './gestures/press.es.js';\nimport { motionEvent } from './utils/events.es.js';\n\nconst gestures = { inView, hover, press };\n/**\n * A list of state types, in priority order. If a value is defined in\n * a righter-most type, it will override any definition in a lefter-most.\n */\nconst stateTypes = [\"initial\", \"animate\", ...Object.keys(gestures), \"exit\"];\n/**\n * A global store of all generated motion states. This can be used to lookup\n * a motion state for a given Element.\n */\nconst mountedStates = new WeakMap();\nfunction createMotionState(options = {}, parent) {\n    /**\n     * The element represented by the motion state. This is an empty reference\n     * when we create the state to support SSR and allow for later mounting\n     * in view libraries.\n     *\n     * @ts-ignore\n     */\n    let element;\n    /**\n     * Calculate a depth that we can use to order motion states by tree depth.\n     */\n    let depth = parent ? parent.getDepth() + 1 : 0;\n    /**\n     * Track which states are currently active.\n     */\n    const activeStates = { initial: true, animate: true };\n    /**\n     * A map of functions that, when called, will remove event listeners for\n     * a given gesture.\n     */\n    const gestureSubscriptions = {};\n    /**\n     * Initialise a context to share through motion states. This\n     * will be populated by variant names (if any).\n     */\n    const context = {};\n    for (const name of stateTypes) {\n        context[name] =\n            typeof options[name] === \"string\"\n                ? options[name]\n                : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];\n    }\n    /**\n     * If initial is set to false we use the animate prop as the initial\n     * animation state.\n     */\n    const initialVariantSource = options.initial === false ? \"animate\" : \"initial\";\n    /**\n     * Destructure an initial target out from the resolved initial variant.\n     */\n    let _a = resolveVariant(options[initialVariantSource] || context[initialVariantSource], options.variants) || {}, target = __rest(_a, [\"transition\"]);\n    /**\n     * The base target is a cached map of values that we'll use to animate\n     * back to if a value is removed from all active state types. This\n     * is usually the initial value as read from the DOM, for instance if\n     * it hasn't been defined in initial.\n     */\n    const baseTarget = Object.assign({}, target);\n    /**\n     * A generator that will be processed by the global animation scheduler.\n     * This yeilds when it switches from reading the DOM to writing to it\n     * to prevent layout thrashing.\n     */\n    function* animateUpdates() {\n        var _a, _b;\n        const prevTarget = target;\n        target = {};\n        const animationOptions = {};\n        for (const name of stateTypes) {\n            if (!activeStates[name])\n                continue;\n            const variant = resolveVariant(options[name]);\n            if (!variant)\n                continue;\n            for (const key in variant) {\n                if (key === \"transition\")\n                    continue;\n                target[key] = variant[key];\n                animationOptions[key] = getOptions((_b = (_a = variant.transition) !== null && _a !== void 0 ? _a : options.transition) !== null && _b !== void 0 ? _b : {}, key);\n            }\n        }\n        const allTargetKeys = new Set([\n            ...Object.keys(target),\n            ...Object.keys(prevTarget),\n        ]);\n        const animationFactories = [];\n        allTargetKeys.forEach((key) => {\n            var _a;\n            if (target[key] === undefined) {\n                target[key] = baseTarget[key];\n            }\n            if (hasChanged(prevTarget[key], target[key])) {\n                (_a = baseTarget[key]) !== null && _a !== void 0 ? _a : (baseTarget[key] = style.get(element, key));\n                animationFactories.push(animateStyle(element, key, target[key], animationOptions[key]));\n            }\n        });\n        // Wait for all animation states to read from the DOM\n        yield;\n        const animations = animationFactories\n            .map((factory) => factory())\n            .filter(Boolean);\n        if (!animations.length)\n            return;\n        const animationTarget = target;\n        element.dispatchEvent(motionEvent(\"motionstart\", animationTarget));\n        Promise.all(animations.map((animation) => animation.finished))\n            .then(() => {\n            element.dispatchEvent(motionEvent(\"motioncomplete\", animationTarget));\n        })\n            .catch(noop);\n    }\n    const setGesture = (name, isActive) => () => {\n        activeStates[name] = isActive;\n        scheduleAnimation(state);\n    };\n    const updateGestureSubscriptions = () => {\n        for (const name in gestures) {\n            const isGestureActive = gestures[name].isActive(options);\n            const remove = gestureSubscriptions[name];\n            if (isGestureActive && !remove) {\n                gestureSubscriptions[name] = gestures[name].subscribe(element, {\n                    enable: setGesture(name, true),\n                    disable: setGesture(name, false),\n                }, options);\n            }\n            else if (!isGestureActive && remove) {\n                remove();\n                delete gestureSubscriptions[name];\n            }\n        }\n    };\n    const state = {\n        update: (newOptions) => {\n            if (!element)\n                return;\n            options = newOptions;\n            updateGestureSubscriptions();\n            scheduleAnimation(state);\n        },\n        setActive: (name, isActive) => {\n            if (!element)\n                return;\n            activeStates[name] = isActive;\n            scheduleAnimation(state);\n        },\n        animateUpdates,\n        getDepth: () => depth,\n        getTarget: () => target,\n        getOptions: () => options,\n        getContext: () => context,\n        mount: (newElement) => {\n            invariant(Boolean(newElement), \"Animation state must be mounted with valid Element\");\n            element = newElement;\n            mountedStates.set(element, state);\n            updateGestureSubscriptions();\n            return () => {\n                mountedStates.delete(element);\n                unscheduleAnimation(state);\n                for (const key in gestureSubscriptions) {\n                    gestureSubscriptions[key]();\n                }\n            };\n        },\n        isMounted: () => Boolean(element),\n    };\n    return state;\n}\n\nexport { createMotionState, mountedStates };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1242, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1247, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/style-object.es.js"],"sourcesContent":["import { isNumber } from '@motionone/utils';\nimport { isTransform, transformAlias, asTransformCssVar, transformDefinitions, buildTransformTemplate } from './transforms.es.js';\n\nfunction createStyles(keyframes) {\n    const initialKeyframes = {};\n    const transformKeys = [];\n    for (let key in keyframes) {\n        const value = keyframes[key];\n        if (isTransform(key)) {\n            if (transformAlias[key])\n                key = transformAlias[key];\n            transformKeys.push(key);\n            key = asTransformCssVar(key);\n        }\n        let initialKeyframe = Array.isArray(value) ? value[0] : value;\n        /**\n         * If this is a number and we have a default value type, convert the number\n         * to this type.\n         */\n        const definition = transformDefinitions.get(key);\n        if (definition) {\n            initialKeyframe = isNumber(value)\n                ? definition.toDefaultUnit(value)\n                : value;\n        }\n        initialKeyframes[key] = initialKeyframe;\n    }\n    if (transformKeys.length) {\n        initialKeyframes.transform = buildTransformTemplate(transformKeys);\n    }\n    return initialKeyframes;\n}\n\nexport { createStyles };\n"],"names":[],"mappings":";;;;;;;;AAGA,SAAS,aAAa,SAAS;IAC3B,MAAM,mBAAmB,CAAC;IAC1B,MAAM,gBAAgB,EAAE;IACxB,IAAK,IAAI,OAAO,UAAW;QACvB,MAAM,QAAQ,SAAS,CAAC,IAAI;QAC5B,IAAI,qMAAY,MAAM;YAClB,IAAI,uMAAc,CAAC,IAAI,EACnB,MAAM,uMAAc,CAAC,IAAI;YAC7B,cAAc,IAAI,CAAC;YACnB,MAAM,2MAAkB;QAC5B;QACA,IAAI,kBAAkB,MAAM,OAAO,CAAC,SAAS,KAAK,CAAC,EAAE,GAAG;QACxD;;;SAGC,GACD,MAAM,aAAa,8MAAqB,GAAG,CAAC;QAC5C,IAAI,YAAY;YACZ,kBAAkB,kLAAS,SACrB,WAAW,aAAa,CAAC,SACzB;QACV;QACA,gBAAgB,CAAC,IAAI,GAAG;IAC5B;IACA,IAAI,cAAc,MAAM,EAAE;QACtB,iBAAiB,SAAS,GAAG,gNAAuB;IACxD;IACA,OAAO;AACX"}},
    {"offset": {"line": 1281, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1286, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/animate/utils/style-string.es.js"],"sourcesContent":["import { createStyles } from './style-object.es.js';\n\nconst camelLetterToPipeLetter = (letter) => `-${letter.toLowerCase()}`;\nconst camelToPipeCase = (str) => str.replace(/[A-Z]/g, camelLetterToPipeLetter);\nfunction createStyleString(target = {}) {\n    const styles = createStyles(target);\n    let style = \"\";\n    for (const key in styles) {\n        style += key.startsWith(\"--\") ? key : camelToPipeCase(key);\n        style += `: ${styles[key]}; `;\n    }\n    return style;\n}\n\nexport { createStyleString };\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,0BAA0B,CAAC,SAAW,CAAC,CAAC,EAAE,OAAO,WAAW,GAAG,CAAC;AACtE,MAAM,kBAAkB,CAAC,MAAQ,IAAI,OAAO,CAAC,UAAU;AACvD,SAAS,kBAAkB,SAAS,CAAC,CAAC;IAClC,MAAM,SAAS,2MAAa;IAC5B,IAAI,QAAQ;IACZ,IAAK,MAAM,OAAO,OAAQ;QACtB,SAAS,IAAI,UAAU,CAAC,QAAQ,MAAM,gBAAgB;QACtD,SAAS,CAAC,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;IACjC;IACA,OAAO;AACX"}},
    {"offset": {"line": 1304, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1309, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js"],"sourcesContent":["import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\n\nfunction createGeneratorEasing(createGenerator) {\n    const keyframesCache = new WeakMap();\n    return (options = {}) => {\n        const generatorCache = new Map();\n        const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\n            const key = `${from}-${to}-${velocity}-${isScale}`;\n            if (!generatorCache.has(key)) {\n                generatorCache.set(key, createGenerator(Object.assign({ from,\n                    to,\n                    velocity, restSpeed: isScale ? 0.05 : 2, restDistance: isScale ? 0.01 : 0.5 }, options)));\n            }\n            return generatorCache.get(key);\n        };\n        const getKeyframes = (generator) => {\n            if (!keyframesCache.has(generator)) {\n                keyframesCache.set(generator, pregenerateKeyframes(generator));\n            }\n            return keyframesCache.get(generator);\n        };\n        return {\n            createAnimation: (keyframes, getOrigin, canUseGenerator, name, motionValue) => {\n                var _a, _b;\n                let settings;\n                const numKeyframes = keyframes.length;\n                let shouldUseGenerator = canUseGenerator &&\n                    numKeyframes <= 2 &&\n                    keyframes.every(isNumberOrNull);\n                if (shouldUseGenerator) {\n                    const target = keyframes[numKeyframes - 1];\n                    const unresolvedOrigin = numKeyframes === 1 ? null : keyframes[0];\n                    let velocity = 0;\n                    let origin = 0;\n                    const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n                    if (prevGenerator) {\n                        /**\n                         * If we have a generator for this value we can use it to resolve\n                         * the animations's current value and velocity.\n                         */\n                        const { animation, generatorStartTime } = motionValue;\n                        const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n                        const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n                        const prevGeneratorCurrent = prevGenerator(currentTime).current;\n                        origin = (_a = unresolvedOrigin) !== null && _a !== void 0 ? _a : prevGeneratorCurrent;\n                        if (numKeyframes === 1 ||\n                            (numKeyframes === 2 && keyframes[0] === null)) {\n                            velocity = calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\n                        }\n                    }\n                    else {\n                        origin = (_b = unresolvedOrigin) !== null && _b !== void 0 ? _b : parseFloat(getOrigin());\n                    }\n                    const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n                    const keyframesMetadata = getKeyframes(generator);\n                    settings = Object.assign(Object.assign({}, keyframesMetadata), { easing: \"linear\" });\n                    // TODO Add test for this\n                    if (motionValue) {\n                        motionValue.generator = generator;\n                        motionValue.generatorStartTime = performance.now();\n                    }\n                }\n                else {\n                    const keyframesMetadata = getKeyframes(getGenerator(0, 100));\n                    settings = {\n                        easing: \"ease\",\n                        duration: keyframesMetadata.overshootDuration,\n                    };\n                }\n                return settings;\n            },\n        };\n    };\n}\nconst isNumberOrNull = (value) => typeof value !== \"string\";\n\nexport { createGeneratorEasing };\n"],"names":[],"mappings":";;;;;;;AAEA,SAAS,sBAAsB,eAAe;IAC1C,MAAM,iBAAiB,IAAI;IAC3B,OAAO,CAAC,UAAU,CAAC,CAAC;QAChB,MAAM,iBAAiB,IAAI;QAC3B,MAAM,eAAe,CAAC,OAAO,CAAC,EAAE,KAAK,GAAG,EAAE,WAAW,CAAC,EAAE,UAAU,KAAK;YACnE,MAAM,MAAM,CAAC,EAAE,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,SAAS,CAAC,EAAE,QAAQ,CAAC;YAClD,IAAI,CAAC,eAAe,GAAG,CAAC,MAAM;gBAC1B,eAAe,GAAG,CAAC,KAAK,gBAAgB,OAAO,MAAM,CAAC;oBAAE;oBACpD;oBACA;oBAAU,WAAW,UAAU,OAAO;oBAAG,cAAc,UAAU,OAAO;gBAAI,GAAG;YACvF;YACA,OAAO,eAAe,GAAG,CAAC;QAC9B;QACA,MAAM,eAAe,CAAC;YAClB,IAAI,CAAC,eAAe,GAAG,CAAC,YAAY;gBAChC,eAAe,GAAG,CAAC,WAAW,wNAAqB;YACvD;YACA,OAAO,eAAe,GAAG,CAAC;QAC9B;QACA,OAAO;YACH,iBAAiB,CAAC,WAAW,WAAW,iBAAiB,MAAM;gBAC3D,IAAI,IAAI;gBACR,IAAI;gBACJ,MAAM,eAAe,UAAU,MAAM;gBACrC,IAAI,qBAAqB,mBACrB,gBAAgB,KAChB,UAAU,KAAK,CAAC;gBACpB,IAAI,oBAAoB;oBACpB,MAAM,SAAS,SAAS,CAAC,eAAe,EAAE;oBAC1C,MAAM,mBAAmB,iBAAiB,IAAI,OAAO,SAAS,CAAC,EAAE;oBACjE,IAAI,WAAW;oBACf,IAAI,SAAS;oBACb,MAAM,gBAAgB,gBAAgB,QAAQ,gBAAgB,KAAK,IAAI,KAAK,IAAI,YAAY,SAAS;oBACrG,IAAI,eAAe;wBACf;;;yBAGC,GACD,MAAM,EAAE,SAAS,EAAE,kBAAkB,EAAE,GAAG;wBAC1C,MAAM,YAAY,CAAC,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,SAAS,KAAK,sBAAsB;wBACvH,MAAM,cAAc,CAAC,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,WAAW,KAAK,YAAY,GAAG,KAAK;wBACzH,MAAM,uBAAuB,cAAc,aAAa,OAAO;wBAC/D,SAAS,CAAC,KAAK,gBAAgB,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK;wBAClE,IAAI,iBAAiB,KAChB,iBAAiB,KAAK,SAAS,CAAC,EAAE,KAAK,MAAO;4BAC/C,WAAW,yMAAsB,CAAC,IAAM,cAAc,GAAG,OAAO,EAAE,aAAa;wBACnF;oBACJ,OACK;wBACD,SAAS,CAAC,KAAK,gBAAgB,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,WAAW;oBACjF;oBACA,MAAM,YAAY,aAAa,QAAQ,QAAQ,UAAU,SAAS,QAAQ,SAAS,KAAK,IAAI,KAAK,IAAI,KAAK,QAAQ,CAAC;oBACnH,MAAM,oBAAoB,aAAa;oBACvC,WAAW,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,CAAC,GAAG,oBAAoB;wBAAE,QAAQ;oBAAS;oBAClF,yBAAyB;oBACzB,IAAI,aAAa;wBACb,YAAY,SAAS,GAAG;wBACxB,YAAY,kBAAkB,GAAG,YAAY,GAAG;oBACpD;gBACJ,OACK;oBACD,MAAM,oBAAoB,aAAa,aAAa,GAAG;oBACvD,WAAW;wBACP,QAAQ;wBACR,UAAU,kBAAkB,iBAAiB;oBACjD;gBACJ;gBACA,OAAO;YACX;QACJ;IACJ;AACJ;AACA,MAAM,iBAAiB,CAAC,QAAU,OAAO,UAAU"}},
    {"offset": {"line": 1390, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1395, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/easing/glide/index.es.js"],"sourcesContent":["import { glide as glide$1 } from '@motionone/generators';\nimport { createGeneratorEasing } from '../create-generator-easing.es.js';\n\nconst glide = createGeneratorEasing(glide$1);\n\nexport { glide };\n"],"names":[],"mappings":";;;;;;;;AAGA,MAAM,QAAQ"}},
    {"offset": {"line": 1405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1410, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/resize/handle-element.es.js"],"sourcesContent":["import { resolveElements } from '../../utils/resolve-elements.es.js';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return { width: inlineSize, height: blockSize };\n    }\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\n        return target.getBBox();\n    }\n    else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight,\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n        handler({\n            target,\n            contentSize: contentRect,\n            get size() {\n                return getElementSize(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,iBAAiB,IAAI;AAC3B,IAAI;AACJ,SAAS,eAAe,MAAM,EAAE,aAAa;IACzC,IAAI,eAAe;QACf,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG,aAAa,CAAC,EAAE;QAClD,OAAO;YAAE,OAAO;YAAY,QAAQ;QAAU;IAClD,OACK,IAAI,kBAAkB,cAAc,aAAa,QAAQ;QAC1D,OAAO,OAAO,OAAO;IACzB,OACK;QACD,OAAO;YACH,OAAO,OAAO,WAAW;YACzB,QAAQ,OAAO,YAAY;QAC/B;IACJ;AACJ;AACA,SAAS,aAAa,EAAE,MAAM,EAAE,WAAW,EAAE,aAAa,EAAG;IACzD,IAAI;IACJ,CAAC,KAAK,eAAe,GAAG,CAAC,OAAO,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,OAAO,CAAC,CAAC;QAC/E,QAAQ;YACJ;YACA,aAAa;YACb,IAAI,QAAO;gBACP,OAAO,eAAe,QAAQ;YAClC;QACJ;IACJ;AACJ;AACA,SAAS,UAAU,OAAO;IACtB,QAAQ,OAAO,CAAC;AACpB;AACA,SAAS;IACL,IAAI,OAAO,mBAAmB,aAC1B;IACJ,WAAW,IAAI,eAAe;AAClC;AACA,SAAS,cAAc,MAAM,EAAE,OAAO;IAClC,IAAI,CAAC,UACD;IACJ,MAAM,WAAW,uMAAgB;IACjC,SAAS,OAAO,CAAC,CAAC;QACd,IAAI,kBAAkB,eAAe,GAAG,CAAC;QACzC,IAAI,CAAC,iBAAiB;YAClB,kBAAkB,IAAI;YACtB,eAAe,GAAG,CAAC,SAAS;QAChC;QACA,gBAAgB,GAAG,CAAC;QACpB,aAAa,QAAQ,aAAa,KAAK,IAAI,KAAK,IAAI,SAAS,OAAO,CAAC;IACzE;IACA,OAAO;QACH,SAAS,OAAO,CAAC,CAAC;YACd,MAAM,kBAAkB,eAAe,GAAG,CAAC;YAC3C,oBAAoB,QAAQ,oBAAoB,KAAK,IAAI,KAAK,IAAI,gBAAgB,MAAM,CAAC;YACzF,IAAI,CAAC,CAAC,oBAAoB,QAAQ,oBAAoB,KAAK,IAAI,KAAK,IAAI,gBAAgB,IAAI,GAAG;gBAC3F,aAAa,QAAQ,aAAa,KAAK,IAAI,KAAK,IAAI,SAAS,SAAS,CAAC;YAC3E;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 1476, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1481, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/resize/handle-window.es.js"],"sourcesContent":["const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size,\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n"],"names":[],"mappings":";;;AAAA,MAAM,kBAAkB,IAAI;AAC5B,IAAI;AACJ,SAAS;IACL,sBAAsB;QAClB,MAAM,OAAO;YACT,OAAO,OAAO,UAAU;YACxB,QAAQ,OAAO,WAAW;QAC9B;QACA,MAAM,OAAO;YACT,QAAQ;YACR;YACA,aAAa;QACjB;QACA,gBAAgB,OAAO,CAAC,CAAC,WAAa,SAAS;IACnD;IACA,OAAO,gBAAgB,CAAC,UAAU;AACtC;AACA,SAAS,aAAa,QAAQ;IAC1B,gBAAgB,GAAG,CAAC;IACpB,IAAI,CAAC,qBACD;IACJ,OAAO;QACH,gBAAgB,MAAM,CAAC;QACvB,IAAI,CAAC,gBAAgB,IAAI,IAAI,qBAAqB;YAC9C,sBAAsB;QAC1B;IACJ;AACJ"}},
    {"offset": {"line": 1512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1517, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/resize/index.es.js"],"sourcesContent":["import { resizeElement } from './handle-element.es.js';\nimport { resizeWindow } from './handle-window.es.js';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n"],"names":[],"mappings":";;;;;;;;AAGA,SAAS,OAAO,CAAC,EAAE,CAAC;IAChB,OAAO,OAAO,MAAM,aAAa,8MAAa,KAAK,gNAAc,GAAG;AACxE"}},
    {"offset": {"line": 1529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1534, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/info.es.js"],"sourcesContent":["import { progress, velocityPerSecond } from '@motionone/utils';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[\"scroll\" + position];\n    axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n"],"names":[],"mappings":";;;;;;;;AAEA;;CAEC,GACD,MAAM,aAAa;AACnB,MAAM,iBAAiB,IAAM,CAAC;QAC1B,SAAS;QACT,QAAQ,EAAE;QACV,UAAU;QACV,cAAc;QACd,cAAc;QACd,cAAc;QACd,iBAAiB;QACjB,UAAU;IACd,CAAC;AACD,MAAM,mBAAmB,IAAM,CAAC;QAC5B,MAAM;QACN,GAAG;QACH,GAAG;IACP,CAAC;AACD,MAAM,OAAO;IACT,GAAG;QACC,QAAQ;QACR,UAAU;IACd;IACA,GAAG;QACC,QAAQ;QACR,UAAU;IACd;AACJ;AACA,SAAS,eAAe,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI;IACjD,MAAM,OAAO,IAAI,CAAC,SAAS;IAC3B,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,SAAS;IAC3C,MAAM,OAAO,KAAK,OAAO;IACzB,MAAM,WAAW,KAAK,IAAI;IAC1B,KAAK,OAAO,GAAG,OAAO,CAAC,WAAW,SAAS;IAC3C,KAAK,YAAY,GAAG,OAAO,CAAC,WAAW,OAAO,GAAG,OAAO,CAAC,WAAW,OAAO;IAC3E,KAAK,MAAM,CAAC,MAAM,GAAG;IACrB,KAAK,MAAM,CAAC,EAAE,GAAG;IACjB,KAAK,MAAM,CAAC,EAAE,GAAG,KAAK,YAAY;IAClC,KAAK,QAAQ,GAAG,8KAAS,GAAG,KAAK,YAAY,EAAE,KAAK,OAAO;IAC3D,MAAM,UAAU,OAAO;IACvB,KAAK,QAAQ,GACT,UAAU,aAAa,IAAI,uLAAkB,KAAK,OAAO,GAAG,MAAM;AAC1E;AACA,SAAS,iBAAiB,OAAO,EAAE,IAAI,EAAE,IAAI;IACzC,eAAe,SAAS,KAAK,MAAM;IACnC,eAAe,SAAS,KAAK,MAAM;IACnC,KAAK,IAAI,GAAG;AAChB"}},
    {"offset": {"line": 1590, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1595, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/offsets/inset.es.js"],"sourcesContent":["function calcInset(element, container) {\n    let inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n            const { top, left } = current.getBBox();\n            inset.x += left;\n            inset.y += top;\n            /**\n             * Assign the next parent element as the <svg /> tag.\n             */\n            while (current && current.tagName !== \"svg\") {\n                current = current.parentNode;\n            }\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n"],"names":[],"mappings":";;;AAAA,SAAS,UAAU,OAAO,EAAE,SAAS;IACjC,IAAI,QAAQ;QAAE,GAAG;QAAG,GAAG;IAAE;IACzB,IAAI,UAAU;IACd,MAAO,WAAW,YAAY,UAAW;QACrC,IAAI,mBAAmB,aAAa;YAChC,MAAM,CAAC,IAAI,QAAQ,UAAU;YAC7B,MAAM,CAAC,IAAI,QAAQ,SAAS;YAC5B,UAAU,QAAQ,YAAY;QAClC,OACK,IAAI,mBAAmB,sBAAsB,aAAa,SAAS;YACpE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,QAAQ,OAAO;YACrC,MAAM,CAAC,IAAI;YACX,MAAM,CAAC,IAAI;YACX;;aAEC,GACD,MAAO,WAAW,QAAQ,OAAO,KAAK,MAAO;gBACzC,UAAU,QAAQ,UAAU;YAChC;QACJ;IACJ;IACA,OAAO;AACX"}},
    {"offset": {"line": 1623, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1628, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/offsets/edge.es.js"],"sourcesContent":["import { isString, isNumber } from '@motionone/utils';\n\nconst namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (namedEdges[edge] !== undefined) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (isString(edge)) {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (isNumber(edge)) {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAM,aAAa;IACf,OAAO;IACP,QAAQ;IACR,KAAK;AACT;AACA,SAAS,YAAY,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC;IACxC,IAAI,QAAQ;IACZ;;;KAGC,GACD,IAAI,UAAU,CAAC,KAAK,KAAK,WAAW;QAChC,OAAO,UAAU,CAAC,KAAK;IAC3B;IACA;;KAEC,GACD,IAAI,kLAAS,OAAO;QAChB,MAAM,WAAW,WAAW;QAC5B,IAAI,KAAK,QAAQ,CAAC,OAAO;YACrB,QAAQ;QACZ,OACK,IAAI,KAAK,QAAQ,CAAC,MAAM;YACzB,OAAO,WAAW;QACtB,OACK,IAAI,KAAK,QAAQ,CAAC,OAAO;YAC1B,QAAQ,AAAC,WAAW,MAAO,SAAS,eAAe,CAAC,WAAW;QACnE,OACK,IAAI,KAAK,QAAQ,CAAC,OAAO;YAC1B,QAAQ,AAAC,WAAW,MAAO,SAAS,eAAe,CAAC,YAAY;QACpE,OACK;YACD,OAAO;QACX;IACJ;IACA;;KAEC,GACD,IAAI,kLAAS,OAAO;QAChB,QAAQ,SAAS;IACrB;IACA,OAAO,QAAQ;AACnB"}},
    {"offset": {"line": 1673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1678, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.es.js"],"sourcesContent":["import { isNumber, isString } from '@motionone/utils';\nimport { resolveEdge, namedEdges } from './edge.es.js';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (isNumber(offset)) {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (isString(offset)) {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n"],"names":[],"mappings":";;;;;;;;;AAGA,MAAM,gBAAgB;IAAC;IAAG;CAAE;AAC5B,SAAS,cAAc,MAAM,EAAE,eAAe,EAAE,YAAY,EAAE,WAAW;IACrE,IAAI,mBAAmB,MAAM,OAAO,CAAC,UAAU,SAAS;IACxD,IAAI,cAAc;IAClB,IAAI,iBAAiB;IACrB,IAAI,kLAAS,SAAS;QAClB;;;;SAIC,GACD,mBAAmB;YAAC;YAAQ;SAAO;IACvC,OACK,IAAI,kLAAS,SAAS;QACvB,SAAS,OAAO,IAAI;QACpB,IAAI,OAAO,QAAQ,CAAC,MAAM;YACtB,mBAAmB,OAAO,KAAK,CAAC;QACpC,OACK;YACD;;;;aAIC,GACD,mBAAmB;gBAAC;gBAAQ,0MAAU,CAAC,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC;aAAC;QAClE;IACJ;IACA,cAAc,4MAAY,gBAAgB,CAAC,EAAE,EAAE,cAAc;IAC7D,iBAAiB,4MAAY,gBAAgB,CAAC,EAAE,EAAE;IAClD,OAAO,cAAc;AACzB"}},
    {"offset": {"line": 1724, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1729, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js"],"sourcesContent":["import { interpolate, defaultOffset } from '@motionone/utils';\nimport { calcInset } from './inset.es.js';\nimport { ScrollOffset } from './presets.es.js';\nimport { resolveOffset } from './offset.es.js';\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(defaultOffset(numOffsets), info[axis].offset);\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n"],"names":[],"mappings":";;;;;;;;;;;;;AAKA,MAAM,QAAQ;IAAE,GAAG;IAAG,GAAG;AAAE;AAC3B,SAAS,eAAe,SAAS,EAAE,IAAI,EAAE,OAAO;IAC5C,IAAI,EAAE,QAAQ,mBAAmB,gNAAa,GAAG,EAAE,GAAG;IACtD,MAAM,EAAE,SAAS,SAAS,EAAE,OAAO,GAAG,EAAE,GAAG;IAC3C,MAAM,cAAc,SAAS,MAAM,WAAW;IAC9C,MAAM,QAAQ,WAAW,YAAY,2MAAU,QAAQ,aAAa;IACpE;;;;KAIC,GACD,MAAM,aAAa,WAAW,YACxB;QAAE,OAAO,UAAU,WAAW;QAAE,QAAQ,UAAU,YAAY;IAAC,IAC/D;QAAE,OAAO,OAAO,WAAW;QAAE,QAAQ,OAAO,YAAY;IAAC;IAC/D,MAAM,gBAAgB;QAClB,OAAO,UAAU,WAAW;QAC5B,QAAQ,UAAU,YAAY;IAClC;IACA;;;KAGC,GACD,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG;IAC3B;;;KAGC,GACD,IAAI,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW;IACxC,MAAM,aAAa,iBAAiB,MAAM;IAC1C,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,IAAK;QACjC,MAAM,SAAS,gNAAc,gBAAgB,CAAC,EAAE,EAAE,aAAa,CAAC,YAAY,EAAE,UAAU,CAAC,YAAY,EAAE,KAAK,CAAC,KAAK;QAClH,IAAI,CAAC,cAAc,WAAW,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,EAAE,EAAE;YAC7D,aAAa;QACjB;QACA,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,GAAG;IAC3B;IACA;;;KAGC,GACD,IAAI,YAAY;QACZ,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,oLAAY,iLAAc,aAAa,IAAI,CAAC,KAAK,CAAC,MAAM;QACjF,IAAI,CAAC,KAAK,CAAC,mBAAmB,GAAG;eAAI,IAAI,CAAC,KAAK,CAAC,MAAM;SAAC;IAC3D;IACA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO;AACnE"}},
    {"offset": {"line": 1794, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1799, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js"],"sourcesContent":["import { noopReturn } from '@motionone/utils';\nimport { updateScrollInfo } from './info.es.js';\nimport { resolveOffsets } from './offsets/index.es.js';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node != container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    const axis = options.axis || \"y\";\n    return {\n        measure: () => measure(element, options.target, info),\n        update: (time) => {\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: typeof onScroll === \"function\"\n            ? () => onScroll(info)\n            : scrubAnimation(onScroll, info[axis]),\n    };\n}\nfunction scrubAnimation(controls, axisInfo) {\n    controls.pause();\n    controls.forEachNative((animation, { easing }) => {\n        var _a, _b;\n        if (animation.updateDuration) {\n            if (!easing)\n                animation.easing = noopReturn;\n            animation.updateDuration(1);\n        }\n        else {\n            const timingOptions = { duration: 1000 };\n            if (!easing)\n                timingOptions.easing = \"linear\";\n            (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\n        }\n    });\n    return () => {\n        controls.currentTime = axisInfo.progress;\n    };\n}\n\nexport { createOnScrollHandler };\n"],"names":[],"mappings":";;;;;;;;;;AAIA,SAAS,QAAQ,SAAS,EAAE,SAAS,SAAS,EAAE,IAAI;IAChD;;KAEC,GACD,KAAK,CAAC,CAAC,YAAY,GAAG;IACtB,KAAK,CAAC,CAAC,YAAY,GAAG;IACtB,IAAI,WAAW,WAAW;QACtB,IAAI,OAAO;QACX,MAAO,QAAQ,QAAQ,UAAW;YAC9B,KAAK,CAAC,CAAC,YAAY,IAAI,KAAK,UAAU;YACtC,KAAK,CAAC,CAAC,YAAY,IAAI,KAAK,SAAS;YACrC,OAAO,KAAK,YAAY;QAC5B;IACJ;IACA,KAAK,CAAC,CAAC,YAAY,GACf,WAAW,YAAY,OAAO,WAAW,GAAG,OAAO,WAAW;IAClE,KAAK,CAAC,CAAC,YAAY,GACf,WAAW,YAAY,OAAO,YAAY,GAAG,OAAO,YAAY;IACpE,KAAK,CAAC,CAAC,eAAe,GAAG,UAAU,WAAW;IAC9C,KAAK,CAAC,CAAC,eAAe,GAAG,UAAU,YAAY;AACnD;AACA,SAAS,sBAAsB,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IAChE,MAAM,OAAO,QAAQ,IAAI,IAAI;IAC7B,OAAO;QACH,SAAS,IAAM,QAAQ,SAAS,QAAQ,MAAM,EAAE;QAChD,QAAQ,CAAC;YACL,sMAAiB,SAAS,MAAM;YAChC,IAAI,QAAQ,MAAM,IAAI,QAAQ,MAAM,EAAE;gBAClC,gNAAe,SAAS,MAAM;YAClC;QACJ;QACA,QAAQ,OAAO,aAAa,aACtB,IAAM,SAAS,QACf,eAAe,UAAU,IAAI,CAAC,KAAK;IAC7C;AACJ;AACA,SAAS,eAAe,QAAQ,EAAE,QAAQ;IACtC,SAAS,KAAK;IACd,SAAS,aAAa,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE;QACzC,IAAI,IAAI;QACR,IAAI,UAAU,cAAc,EAAE;YAC1B,IAAI,CAAC,QACD,UAAU,MAAM;YACpB,UAAU,cAAc,CAAC;QAC7B,OACK;YACD,MAAM,gBAAgB;gBAAE,UAAU;YAAK;YACvC,IAAI,CAAC,QACD,cAAc,MAAM,GAAG;YAC3B,CAAC,KAAK,CAAC,KAAK,UAAU,MAAM,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,YAAY,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,IAAI,CAAC,IAAI;QACzI;IACJ;IACA,OAAO;QACH,SAAS,WAAW,GAAG,SAAS,QAAQ;IAC5C;AACJ"}},
    {"offset": {"line": 1860, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1865, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/gestures/scroll/index.es.js"],"sourcesContent":["import { __rest } from 'tslib';\nimport { resize } from '../resize/index.es.js';\nimport { createScrollInfo } from './info.es.js';\nimport { createOnScrollHandler } from './on-scroll-handler.es.js';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scroll(onScroll, _a = {}) {\n    var { container = document.documentElement } = _a, options = __rest(_a, [\"container\"]);\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const listener = () => {\n            const time = performance.now();\n            for (const handler of containerHandlers)\n                handler.measure();\n            for (const handler of containerHandlers)\n                handler.update(time);\n            for (const handler of containerHandlers)\n                handler.notify();\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n    }\n    const listener = scrollListeners.get(container);\n    const onLoadProcesss = requestAnimationFrame(listener);\n    return () => {\n        var _a;\n        if (typeof onScroll !== \"function\")\n            onScroll.stop();\n        cancelAnimationFrame(onLoadProcesss);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const containerHandlers = onScrollHandlers.get(container);\n        if (!containerHandlers)\n            return;\n        containerHandlers.delete(containerHandler);\n        if (containerHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const listener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (listener) {\n            getEventTarget(container).removeEventListener(\"scroll\", listener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener(\"resize\", listener);\n        }\n    };\n}\n\nexport { scroll };\n"],"names":[],"mappings":";;;;;;;;;;;;AAKA,MAAM,kBAAkB,IAAI;AAC5B,MAAM,kBAAkB,IAAI;AAC5B,MAAM,mBAAmB,IAAI;AAC7B,MAAM,iBAAiB,CAAC,UAAY,YAAY,SAAS,eAAe,GAAG,SAAS;AACpF,SAAS,OAAO,QAAQ,EAAE,KAAK,CAAC,CAAC;IAC7B,IAAI,EAAE,YAAY,SAAS,eAAe,EAAE,GAAG,IAAI,UAAU,oJAAO,IAAI;QAAC;KAAY;IACrF,IAAI,oBAAoB,iBAAiB,GAAG,CAAC;IAC7C;;;KAGC,GACD,IAAI,CAAC,mBAAmB;QACpB,oBAAoB,IAAI;QACxB,iBAAiB,GAAG,CAAC,WAAW;IACpC;IACA;;KAEC,GACD,MAAM,OAAO;IACb,MAAM,mBAAmB,8NAAsB,WAAW,UAAU,MAAM;IAC1E,kBAAkB,GAAG,CAAC;IACtB;;;KAGC,GACD,IAAI,CAAC,gBAAgB,GAAG,CAAC,YAAY;QACjC,MAAM,WAAW;YACb,MAAM,OAAO,YAAY,GAAG;YAC5B,KAAK,MAAM,WAAW,kBAClB,QAAQ,OAAO;YACnB,KAAK,MAAM,WAAW,kBAClB,QAAQ,MAAM,CAAC;YACnB,KAAK,MAAM,WAAW,kBAClB,QAAQ,MAAM;QACtB;QACA,gBAAgB,GAAG,CAAC,WAAW;QAC/B,MAAM,SAAS,eAAe;QAC9B,OAAO,gBAAgB,CAAC,UAAU,UAAU;YAAE,SAAS;QAAK;QAC5D,IAAI,cAAc,SAAS,eAAe,EAAE;YACxC,gBAAgB,GAAG,CAAC,WAAW,6LAAO,WAAW;QACrD;QACA,OAAO,gBAAgB,CAAC,UAAU,UAAU;YAAE,SAAS;QAAK;IAChE;IACA,MAAM,WAAW,gBAAgB,GAAG,CAAC;IACrC,MAAM,iBAAiB,sBAAsB;IAC7C,OAAO;QACH,IAAI;QACJ,IAAI,OAAO,aAAa,YACpB,SAAS,IAAI;QACjB,qBAAqB;QACrB;;SAEC,GACD,MAAM,oBAAoB,iBAAiB,GAAG,CAAC;QAC/C,IAAI,CAAC,mBACD;QACJ,kBAAkB,MAAM,CAAC;QACzB,IAAI,kBAAkB,IAAI,EACtB;QACJ;;SAEC,GACD,MAAM,WAAW,gBAAgB,GAAG,CAAC;QACrC,gBAAgB,MAAM,CAAC;QACvB,IAAI,UAAU;YACV,eAAe,WAAW,mBAAmB,CAAC,UAAU;YACxD,CAAC,KAAK,gBAAgB,GAAG,CAAC,UAAU,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI;YAC3E,OAAO,mBAAmB,CAAC,UAAU;QACzC;IACJ;AACJ"}},
    {"offset": {"line": 1944, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1949, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/easing/spring/index.es.js"],"sourcesContent":["import { spring as spring$1 } from '@motionone/generators';\nimport { createGeneratorEasing } from '../create-generator-easing.es.js';\n\nconst spring = createGeneratorEasing(spring$1);\n\nexport { spring };\n"],"names":[],"mappings":";;;;;;;;AAGA,MAAM,SAAS"}},
    {"offset": {"line": 1959, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1964, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/timeline/utils/calc-time.es.js"],"sourcesContent":["import { isNumber } from '@motionone/utils';\n\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (isNumber(next)) {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nexport { calcNextTime };\n"],"names":[],"mappings":";;;;;;AAEA,SAAS,aAAa,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM;IAC7C,IAAI;IACJ,IAAI,kLAAS,OAAO;QAChB,OAAO;IACX,OACK,IAAI,KAAK,UAAU,CAAC,QAAQ,KAAK,UAAU,CAAC,MAAM;QACnD,OAAO,KAAK,GAAG,CAAC,GAAG,UAAU,WAAW;IAC5C,OACK,IAAI,SAAS,KAAK;QACnB,OAAO;IACX,OACK;QACD,OAAO,CAAC,KAAK,OAAO,GAAG,CAAC,KAAK,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK;IACpE;AACJ"}},
    {"offset": {"line": 1983, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1988, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/timeline/utils/edit.es.js"],"sourcesContent":["import { mix, getEasingForSegment, removeItem } from '@motionone/utils';\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nexport { addKeyframes, eraseKeyframes };\n"],"names":[],"mappings":";;;;;;;;;AAEA,SAAS,eAAe,QAAQ,EAAE,SAAS,EAAE,OAAO;IAChD,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACtC,MAAM,WAAW,QAAQ,CAAC,EAAE;QAC5B,IAAI,SAAS,EAAE,GAAG,aAAa,SAAS,EAAE,GAAG,SAAS;YAClD,6KAAW,UAAU;YACrB,8DAA8D;YAC9D;QACJ;IACJ;AACJ;AACA,SAAS,aAAa,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO;IACzE;;;;KAIC,GACD,eAAe,UAAU,WAAW;IACpC,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QACvC,SAAS,IAAI,CAAC;YACV,OAAO,SAAS,CAAC,EAAE;YACnB,IAAI,oKAAI,WAAW,SAAS,MAAM,CAAC,EAAE;YACrC,QAAQ,uLAAoB,QAAQ;QACxC;IACJ;AACJ"}},
    {"offset": {"line": 2022, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2027, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/timeline/utils/sort.es.js"],"sourcesContent":["function compareByTime(a, b) {\n    if (a.at === b.at) {\n        return a.value === null ? 1 : -1;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nexport { compareByTime };\n"],"names":[],"mappings":";;;AAAA,SAAS,cAAc,CAAC,EAAE,CAAC;IACvB,IAAI,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE;QACf,OAAO,EAAE,KAAK,KAAK,OAAO,IAAI,CAAC;IACnC,OACK;QACD,OAAO,EAAE,EAAE,GAAG,EAAE,EAAE;IACtB;AACJ"}},
    {"offset": {"line": 2038, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2043, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@motionone/dom/dist/timeline/index.es.js"],"sourcesContent":["import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { withControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { isTransform } from '../animate/utils/transforms.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle(...definition))\n        .filter(Boolean);\n    return withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = __rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes, options = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options.at !== undefined) {\n            currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframesList(keyframes[key]);\n                const valueOptions = getOptions(options, key);\n                let { duration = defaultOptions.duration || defaults.duration, easing = defaultOptions.easing || defaults.easing, } = valueOptions;\n                if (isEasingGenerator(easing)) {\n                    const valueIsTransform = isTransform(key);\n                    invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexport { createAnimationsFromTimeline, timeline };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}